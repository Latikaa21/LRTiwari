# -*- coding: utf-8 -*-
"""POE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D4Zj2RPAN2DSG8MjzM6sm-06V2qvHmk-
"""

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity

# Example data for sellers (property attributes) and buyers (preferences)
sellers_data = pd.DataFrame({
    'property_id': [1, 2, 3],
    'location': ['Mumbai', 'Pune', 'Delhi'],
    'food_preference': ['Veg', 'Non-Veg', 'Veg'],
    'price': [50000, 40000, 45000],
    'amenities': ['Electricity, Gym', 'Water, Parking', 'Electricity, Pool'],
    'size': [1500, 1200, 1400],
    'religion': ['Any', 'Any', 'Hindu'],
    'community': ['Open', 'Closed', 'Open'],
    'electric_supply': [1, 1, 0],  # 1 for 24/7 supply, 0 otherwise
    'water_supply': [1, 1, 1]
})

buyers_data = pd.DataFrame({
    'buyer_id': [101, 102],
    'location_preference': ['Mumbai', 'Delhi'],
    'food_preference': ['Veg', 'Non-Veg'],
    'price_range': [55000, 45000],
    'preferred_amenities': ['Electricity, Gym', 'Water, Parking'],
    'size_preference': [1600, 1300],
    'religion_preference': ['Any', 'Hindu'],
    'community_preference': ['Open', 'Open'],
    'requires_electric_supply': [1, 0],  # 1 for 24/7 supply required, 0 otherwise
    'requires_water_supply': [1, 1]
})

# One-hot encoding for categorical features
sellers_data_encoded = pd.get_dummies(sellers_data, columns=['location', 'food_preference', 'amenities', 'religion', 'community'])
buyers_data_encoded = pd.get_dummies(buyers_data, columns=['location_preference', 'food_preference', 'preferred_amenities', 'religion_preference', 'community_preference'])

# Align columns (add missing columns in buyers_data_encoded or sellers_data_encoded)
buyers_data_encoded, sellers_data_encoded = buyers_data_encoded.align(sellers_data_encoded, join='outer', axis=1, fill_value=0)

# Display encoded data (after alignment)
print(sellers_data_encoded.head())
print(buyers_data_encoded.head())

# Separate scalers for sellers and buyers, since they have different feature names
scaler_sellers = StandardScaler()
scaler_buyers = StandardScaler()

# Scale price and size for sellers
sellers_data_encoded[['price', 'size']] = scaler_sellers.fit_transform(sellers_data_encoded[['price', 'size']])

# Scale price_range and size_preference for buyers
buyers_data_encoded[['price_range', 'size_preference']] = scaler_buyers.fit_transform(buyers_data_encoded[['price_range', 'size_preference']])

# Calculate the relevance (cosine similarity) between each buyer's preferences and each seller's property
relevance_scores = cosine_similarity(buyers_data_encoded.drop('buyer_id', axis=1), sellers_data_encoded.drop('property_id', axis=1))

# Display the relevance scores for each buyer-seller pair
relevance_df = pd.DataFrame(relevance_scores, index=buyers_data['buyer_id'], columns=sellers_data['property_id'])
print("Relevance Scores between Buyers and Sellers:")
print(relevance_df)

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity

# (Previous steps to compute relevance)

# After computing relevance_df (which contains relevance scores for each buyer and seller)
print("Relevance Scores between Buyers and Sellers:")
print(relevance_df)

# Step 1: Rank properties for each buyer based on relevance scores (highest first)
ranked_results = relevance_df.apply(lambda row: row.sort_values(ascending=False).index.tolist(), axis=1)

# Step 2: Display the ranked properties for each buyer
ranked_results_df = pd.DataFrame(ranked_results, columns=["Ranked_Property_IDs"])

print("\nRanked Property IDs for each Buyer (Best to Worst Match):")
print(ranked_results_df)

from google.colab import files
import pandas as pd

# Step 1: Upload the Excel file from your local system
uploaded = files.upload()

# Load the dataset
file_name = list(uploaded.keys())[0]
data = pd.read_excel(file_name)

# View the first few rows of the dataset to confirm upload
print(data.head())

# Step 2: Separate buyer and seller data based on the 'type' column
buyers_data = data[data['type'] == 'buyer']  # Filter rows where 'type' is 'buyer'
sellers_data = data[data['type'] == 'seller']  # Filter rows where 'type' is 'seller']

# Verify separation
print("Buyers Data:")
print(buyers_data.head())
print("\nSellers Data:")
print(sellers_data.head())

# Step 3: One-hot encode categorical columns
buyers_data_encoded = pd.get_dummies(buyers_data, columns=['location', 'food_preference', 'amenities', 'religion', 'community'])
sellers_data_encoded = pd.get_dummies(sellers_data, columns=['location', 'food_preference', 'amenities', 'religion', 'community'])

# Align the columns to ensure both buyers and sellers have the same features
buyers_data_encoded, sellers_data_encoded = buyers_data_encoded.align(sellers_data_encoded, join='outer', axis=1, fill_value=0)

# Display encoded data to confirm alignment
print(buyers_data_encoded.head())
print(sellers_data_encoded.head())

from google.colab import files
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity

# Step 1: Upload the Excel file
uploaded = files.upload()

# Load the dataset
file_name = list(uploaded.keys())[0]
data = pd.read_excel(file_name)

# View the first few rows of the dataset to confirm upload
print(data.head())

# Step 2: Separate buyer and seller data based on the 'type' column
buyers_data = data[data['type'] == 'buyer']  # Filter rows where 'type' is 'buyer'
sellers_data = data[data['type'] == 'seller']  # Filter rows where 'type' is 'seller']

# Step 3: Drop any unnecessary columns like 'type' that contain non-numeric data
buyers_data = buyers_data.drop(columns=['type'])
sellers_data = sellers_data.drop(columns=['type'])

# Step 4: One-hot encode categorical columns
buyers_data_encoded = pd.get_dummies(buyers_data, columns=['location', 'food_preference', 'amenities', 'religion', 'community'])
sellers_data_encoded = pd.get_dummies(sellers_data, columns=['location', 'food_preference', 'amenities', 'religion', 'community'])

# Align the columns to ensure both buyers and sellers have the same features
buyers_data_encoded, sellers_data_encoded = buyers_data_encoded.align(sellers_data_encoded, join='outer', axis=1, fill_value=0)

# Step 5: Check for missing values in the encoded data
print("Missing values in buyers_data_encoded:")
print(buyers_data_encoded.isnull().sum())

print("Missing values in sellers_data_encoded:")
print(sellers_data_encoded.isnull().sum())

# Step 6: Handle missing values (NaN) by filling with 0 or other appropriate values
buyers_data_encoded = buyers_data_encoded.fillna(0)
sellers_data_encoded = sellers_data_encoded.fillna(0)

# Verify again if NaNs are present after filling
print("After filling NaNs - buyers_data_encoded:")
print(buyers_data_encoded.isnull().sum())

print("After filling NaNs - sellers_data_encoded:")
print(sellers_data_encoded.isnull().sum())

# Step 7: Standardize price and size columns
scaler = StandardScaler()

# Assuming 'price' and 'size' are the correct columns for both buyers and sellers
buyers_data_encoded[['price', 'size']] = scaler.fit_transform(buyers_data_encoded[['price', 'size']])
sellers_data_encoded[['price', 'size']] = scaler.transform(sellers_data_encoded[['price', 'size']])

# Step 8: Compute cosine similarity between buyers' preferences and sellers' properties
# Drop identifiers like buyer_id, property_id before calculating similarity
if 'buyer_id' in buyers_data_encoded.columns:
    buyers_data_encoded = buyers_data_encoded.drop(columns=['buyer_id'])
if 'property_id' in sellers_data_encoded.columns:
    sellers_data_encoded = sellers_data_encoded.drop(columns=['property_id'])

# Calculate cosine similarity
relevance_scores = cosine_similarity(buyers_data_encoded, sellers_data_encoded)

# Convert the similarity results to a DataFrame for easy interpretation
relevance_df = pd.DataFrame(relevance_scores, index=buyers_data['buyer_id'], columns=sellers_data['property_id'])

# Display the relevance scores between buyers and sellers
print("Relevance Scores between Buyers and Sellers:")
print(relevance_df)

# Step 9: Rank the properties for each buyer based on relevance scores (highest to lowest)
ranked_results = relevance_df.apply(lambda row: row.sort_values(ascending=False).index.tolist(), axis=1)

# Convert to DataFrame for easy viewing
ranked_results_df = pd.DataFrame(ranked_results, columns=["Ranked_Property_IDs"])

# Display ranked results
print("\nRanked Property IDs for each Buyer (Best to Worst Match):")
print(ranked_results_df)